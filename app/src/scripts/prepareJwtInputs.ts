import * as fs from 'node:fs';
import * as path from 'node:path';
// Remove ESM-specific imports when targeting CJS
// import { fileURLToPath } from 'node:url';
// Reverting back to standard named ESM import, as dictated by noir-jwt's exports map
import { generateInputs } from 'noir-jwt'; 

import type { JWK } from 'jose'; // Import JWK type if needed for clarity

// Define a type for the noir-jwt output structure that includes .storage
type NoirInputData = { storage: number[]; len: number };

// --- Configuration ---
// CJS doesn't need import.meta.url; __dirname is available globally
// const __filename = fileURLToPath(import.meta.url);
// const __dirname = path.dirname(__filename); // __dirname is global in CJS

// 1. Path to the JWT VC file generated by createJwtVc.ts
const JWT_VC_FILE = path.resolve(process.cwd(), 'config', 'credential.jwt');

// 2. Path to the issuer's config file containing the public key JWK
// Assuming the public key is in the DID document generated by createIssuer.ts
// const configDir = path.resolve(__dirname, '../../config'); // Keep for reference if needed
// const issuerDidPath = path.join(configDir, 'issuer.did.json'); // Keep for reference if needed

// 3. Define the max data length matching your Noir circuit constant
// Replace 1024 with the actual value from your circuit's JWT setup
const MAX_SIGNED_DATA_LENGTH = 900;

// Optional: Specify claim keys for partial SHA precomputation if your circuit uses it
// const shaPrecomputeTillKeys = ['claim_key1', 'claim_key2']; // Example

// --- Load Issuer Public Key ---
function findIssuerPublicKey(didDocPath: string): JWK {
    if (!fs.existsSync(didDocPath)) {
        throw new Error(`Issuer DID document not found at: ${didDocPath}. Run 'npm run create-issuer' first.`);
    }
    const didDocument = JSON.parse(fs.readFileSync(didDocPath, 'utf-8'));

    // Assuming the structure created by createIssuer.ts
    const verificationMethod = didDocument?.verificationMethod?.[0];
    if (!verificationMethod || !verificationMethod.publicKeyJwk) {
        throw new Error(`Could not find publicKeyJwk in the first verification method of ${didDocPath}`);
    }

    // Ensure the key algorithm matches what noir-jwt expects (e.g., RS256)
    // Add checks here if necessary based on your VC and circuit
    // E.g., if (verificationMethod.publicKeyJwk.alg !== 'RS256') ...

    return verificationMethod.publicKeyJwk as JWK;
}

// --- Main Logic ---
async function prepareInputs() {
    console.log('--- Preparing Inputs for Noir JWT Circuit ---');

    // Read the JWT VC from the file
    let jwtVcString: string;
    try {
        jwtVcString = fs.readFileSync(JWT_VC_FILE, 'utf-8').trim();
        console.log(`JWT VC loaded from: ${JWT_VC_FILE}`);
    } catch (err) {
        console.error(`Error: Could not read JWT VC file at: ${JWT_VC_FILE}`);
        console.error("Please ensure 'npm run create-vc' was run successfully.");
        process.exit(1);
    }

    try {
        // Ensure configDir resolves correctly from the project root when run via npm
        const resolvedConfigDir = path.resolve(process.cwd(), 'config');
        const resolvedIssuerDidPath = path.join(resolvedConfigDir, 'issuer.did.json');

        const issuerPublicKeyJwk = findIssuerPublicKey(resolvedIssuerDidPath);
        console.log('Issuer Public Key JWK loaded.');
        // console.log(issuerPublicKeyJwk); // Optional: Log the key

        // Check if the key is RS256 if that's what the circuit expects
        if (issuerPublicKeyJwk.kty !== 'RSA') {
             console.warn(`Warning: Issuer public key kty is ${issuerPublicKeyJwk.kty}, but noir-jwt currently supports RSA.`);
             // Decide if this is an error or just a warning based on your specific circuit implementation
        }


        console.log(`\nGenerating inputs using maxSignedDataLength: ${MAX_SIGNED_DATA_LENGTH}...`);

        // Call the SDK function (using the statically imported generateInputs)
        const noirInputs = await generateInputs({
            jwt: jwtVcString,
            pubkey: issuerPublicKeyJwk,
            maxSignedDataLength: MAX_SIGNED_DATA_LENGTH,
            // shaPrecomputeTillKeys: shaPrecomputeTillKeys, // Uncomment if using partial hashing
        });

        console.log('\n--- Formatting Inputs for Prover.toml ---');

        // Helper to format array values as TOML hex strings
        const formatHexArray = (arr: (number | bigint | string)[] | undefined): string => {
            if (!arr) return '[]';
            return '[' + arr.map(val => `"0x${BigInt(val).toString(16)}"`).join(', ') + ']';
        };
        
        // Helper to safely get the array from noirInputs, handling the {storage, len} structure
        const getArrayFromNoirInput = (input: NoirInputData | (number | bigint | string)[] | undefined): (number | bigint | string)[] | undefined => {
            if (!input) return undefined;
            if (typeof input === 'object' && 'storage' in input && Array.isArray((input as NoirInputData).storage)) {
                return (input as NoirInputData).storage;
            }
            if (Array.isArray(input)) {
                 return input;
            }
            console.warn("Unexpected input format for array formatting:", input);
            return undefined; // Or handle error appropriately
        };

        // Construct the TOML content
        let tomlContent = `# Inputs for Noir JWT circuit, generated by prepareJwtInputs.ts\n\n`;
        tomlContent += `data = ${formatHexArray(getArrayFromNoirInput(noirInputs.data))}\n`;
        tomlContent += `signature_limbs = ${formatHexArray(getArrayFromNoirInput(noirInputs.signature_limbs))}\n`; // Assuming limbs might also follow this pattern
        tomlContent += `pubkey_modulus_limbs = ${formatHexArray(getArrayFromNoirInput(noirInputs.pubkey_modulus_limbs))}\n`; // Assuming limbs might also follow this pattern
        tomlContent += `redc_params_limbs = ${formatHexArray(getArrayFromNoirInput(noirInputs.redc_params_limbs))}\n`; // Assuming limbs might also follow this pattern
        tomlContent += `base64_decode_offset = ${noirInputs.base64_decode_offset}\n`;

        // Handle optional partial hash fields if they exist
        if (noirInputs.partial_data && noirInputs.partial_hash && noirInputs.full_data_length !== undefined) {
            console.log("(Including partial hash inputs in TOML)");
            tomlContent += `partial_data = ${formatHexArray(getArrayFromNoirInput(noirInputs.partial_data))}\n`;
            tomlContent += `partial_hash = ${formatHexArray(getArrayFromNoirInput(noirInputs.partial_hash))}\n`;
            tomlContent += `full_data_length = ${noirInputs.full_data_length}\n`;
        }
        
        // Add expected nationality claim value (encoded as bytes)
        const expectedNationalityValue = "FI";
        const expectedNationalityBytes = Array.from(Buffer.from(expectedNationalityValue, 'utf-8')).map(b => `"0x${b.toString(16)}"`);
        tomlContent += `\n# Expected claim values (public inputs)\n`;
        tomlContent += `expected_nationality = [${expectedNationalityBytes.join(', ')}]\n`;

        // Define output path (relative to project root)
        const proverTomlPath = path.resolve(process.cwd(), 'Prover.toml');

        // Write the TOML file
        fs.writeFileSync(proverTomlPath, tomlContent);
        console.log(`\nProver inputs written to: ${proverTomlPath}`);

        /* Remove old console logs
        console.log('\n--- Generated Noir Inputs ---');
        // TODO: Format these inputs exactly as needed for your Prover.toml
        console.log('Data (Signed Portion):', noirInputs.data); // Likely needs formatting (e.g., array of bytes)
        console.log('Signature Limbs:', noirInputs.signature_limbs); // Already formatted? Check Noir circuit needs
        console.log('Pubkey Modulus Limbs:', noirInputs.pubkey_modulus_limbs); // Already formatted?
        console.log('Redc Params Limbs:', noirInputs.redc_params_limbs); // Already formatted?
        console.log('Base64 Decode Offset:', noirInputs.base64_decode_offset);
        // If using partial hash:
        // console.log('Partial Data:', noirInputs.partial_data);
        // console.log('Partial Hash:', noirInputs.partial_hash);
        // console.log('Full Data Length:', noirInputs.full_data_length);

        console.log('\nTODO: Format the above outputs for Prover.toml');
        */

    } catch (error) {
        console.error('\nError preparing inputs:', error);
        process.exitCode = 1;
    }
}

prepareInputs(); 