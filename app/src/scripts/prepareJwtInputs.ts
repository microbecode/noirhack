import * as fs from 'node:fs';
import * as path from 'node:path';
import { Buffer } from 'node:buffer'; // Ensure Buffer is imported
// Import from the local helper file with .js extension
import { generateInputs, JWTHelperOutput } from '../helpers/jwtInputs.js';
// Import JWK type from jose for clarity, assuming it's installed
import type { JWK } from 'jose';

// --- Configuration ---
// Path to the JWT VC file generated by createJwtVc.ts
const JWT_VC_FILE = path.resolve(process.cwd(), 'config', 'credential.jwt');
// Path to the issuer's config file (assuming relative to cwd where script is run)
const ISSUER_DID_FILE = path.resolve(process.cwd(), 'config', 'issuer.did.json');
// Define the max data length matching the circuit
const MAX_SIGNED_DATA_LENGTH = 440; // <<< UPDATED to 440
// Payload is now 300 bytes -> 400 Base64url chars (no padding)
const MAX_PAYLOAD_B64_LENGTH = 400; 
// Define max claim length matching circuit
const MAX_CLAIM_LENGTH = 10; // <<< UPDATED to 10
// const MAX_DECODED_LENGTH = 300; // <<< REMOVED as unused in this script
// Define expected claim value (ensure consistency with App.tsx if needed)
const EXPECTED_NATIONALITY_VALUE = "FIN";
const NATIONALITY_CLAIM_KEY = "\"nationality\""; // Key with quotes for searching

// Placeholder Wallet Address (replace with actual address as needed)
const PLACEHOLDER_WALLET_ADDRESS = "0x1234567890abcdef1234567890abcdef12345678"; 

// --- Load Issuer Public Key ---
function findIssuerPublicKey(didDocPath: string): JWK {
    console.log(`[prepareJwtInputs] Reading issuer DID from: ${didDocPath}`);
    if (!fs.existsSync(didDocPath)) {
        throw new Error(`Issuer DID document not found at: ${didDocPath}. Run 'npm run create-issuer' first.`);
    }
    const didDocument = JSON.parse(fs.readFileSync(didDocPath, 'utf-8'));

    const verificationMethod = didDocument?.verificationMethod?.[0];
    if (!verificationMethod || !verificationMethod.publicKeyJwk) {
        throw new Error(`Could not find publicKeyJwk in the first verification method of ${didDocPath}`);
    }
    console.log("[prepareJwtInputs] Found verification method with JWK.");
    return verificationMethod.publicKeyJwk as JWK;
}

// --- Helper to get Array or undefined ---
// Handles {storage, len} structure or direct arrays
const getArrayFromNoirInput = (input: { storage: number[]; len: number } | string[] | undefined): number[] | string[] | undefined => {
    if (!input) return undefined;
    if (typeof input === 'object' && 'storage' in input && Array.isArray(input.storage)) {
        return input.storage;
    }
    if (Array.isArray(input)) {
        return input;
    }
    console.warn("[prepareJwtInputs] Unexpected input format for array retrieval:", input);
    return undefined;
};

// --- TOML Formatting ---
const formatTomlValue = (value: any): string => {
    if (typeof value === 'string' && value.startsWith('0x')) {
        return `"${value}"`; // Keep hex strings quoted
    } else if (typeof value === 'string') {
        return `"${value}"`; // Quote regular strings
    } else if (typeof value === 'number' || typeof value === 'bigint') {
        return value.toString();
    } else if (Array.isArray(value)) {
        return `[${value.map(formatTomlValue).join(", ")}]`;
    } else {
        return JSON.stringify(value); // Fallback
    }
};


// --- Main Logic ---
async function prepareInputs() {
    console.log('[prepareJwtInputs] Script started');
    console.log('--- Preparing Inputs for Noir JWT Circuit ---');

    // Read the JWT VC
    let jwtVcString: string;
    try {
        console.log(`[prepareJwtInputs] Reading JWT VC file: ${JWT_VC_FILE}`);
        jwtVcString = fs.readFileSync(JWT_VC_FILE, 'utf-8').trim();
        console.log(`[prepareJwtInputs] JWT VC loaded.`);
    } catch (err) {
        console.error(`[prepareJwtInputs] Error reading JWT VC file: ${JWT_VC_FILE}`, err);
        process.exit(1);
    }

    try {
        // Load Issuer Key
        const issuerPublicKeyJwk = findIssuerPublicKey(ISSUER_DID_FILE);
        console.log('[prepareJwtInputs] Issuer Public Key JWK loaded.');
        if (issuerPublicKeyJwk.kty !== 'RSA') {
             console.warn(`[prepareJwtInputs] Warning: Issuer key kty is ${issuerPublicKeyJwk.kty}. Circuit expects RSA.`);
        }

        // 1. Generate base signature/RSA inputs
        console.log(`[prepareJwtInputs] Calling local generateInputs helper...`);
        const baseInputs: JWTHelperOutput = await generateInputs({
            jwt: jwtVcString,
            pubkey: issuerPublicKeyJwk,
            maxSignedDataLength: MAX_SIGNED_DATA_LENGTH,
        });
        console.log('[prepareJwtInputs] Local generateInputs helper returned.');

        // 2. Calculate Claim Indices and other required fields 
        console.log('[prepareJwtInputs] Calculating claim indices and lengths...');
        const payloadB64 = jwtVcString.split('.')[1]; // <<< Original unpadded B64 string
        const decodedPayloadBuffer = Buffer.from(payloadB64, 'base64url');
        const decodedPayload = decodedPayloadBuffer.toString('utf-8');
        const decoded_payload_len = decodedPayloadBuffer.length; 
        
        // --- REMOVED Base64 padding calculation --- 
        // let paddedPayloadB64 = payloadB64;
        // const paddingNeeded = payloadB64.length % 4;
        // if (paddingNeeded > 0) { ... }
        // console.log(...) 
        // --- End REMOVED Base64 padding calculation --- 

        const keyIndex = decodedPayload.indexOf(NATIONALITY_CLAIM_KEY);
        if (keyIndex === -1) {
            throw new Error(`Could not find key ${NATIONALITY_CLAIM_KEY} in decoded payload: ${decodedPayload}`);
        }
        
        // Find the start of the value (after ":" and potentially whitespace/quote)
        const valueStartIndexSearch = keyIndex + NATIONALITY_CLAIM_KEY.length;
        const colonIndex = decodedPayload.indexOf(':', valueStartIndexSearch);
        if (colonIndex === -1) {
             throw new Error(`Could not find colon after key ${NATIONALITY_CLAIM_KEY}`);
        }
        // Assume value is quoted, find the opening quote
        const openingQuoteIndex = decodedPayload.indexOf('"', colonIndex + 1);
         if (openingQuoteIndex === -1) {
             throw new Error(`Could not find opening quote for value of key ${NATIONALITY_CLAIM_KEY}`);
         }
         const nationality_start_index = openingQuoteIndex + 1; // Index *after* the opening quote
         
         // Find the closing quote to double-check the value (optional but good practice)
         const closingQuoteIndex = decodedPayload.indexOf('"', nationality_start_index);
         if (closingQuoteIndex === -1) {
             throw new Error(`Could not find closing quote for value of key ${NATIONALITY_CLAIM_KEY}`);
         }
         const extractedValue = decodedPayload.substring(nationality_start_index, closingQuoteIndex);
         if (extractedValue !== EXPECTED_NATIONALITY_VALUE) {
            throw new Error(`Extracted value "${extractedValue}" does not match expected "${EXPECTED_NATIONALITY_VALUE}"`);
         }
        
        const nationality_value_len = EXPECTED_NATIONALITY_VALUE.length; // Should be 3
        console.log(`[prepareJwtInputs] Found nationality value "${EXPECTED_NATIONALITY_VALUE}" at index ${nationality_start_index} with length ${nationality_value_len}`);
        
        // Create claim_value_indices array
        const claim_value_indices = [nationality_start_index, nationality_start_index + nationality_value_len]; // <<< Create indices array

        // --- Create payload_b64_storage with MAX size, using ORIGINAL UNPADDED B64 string --- 
        const payloadB64Len = payloadB64.length;
        console.log(`[prepareJwtInputs] Actual payload Base64 length: ${payloadB64Len}`);

        // Ensure the actual length matches the new constant
        if (payloadB64Len !== MAX_PAYLOAD_B64_LENGTH) {
            throw new Error(`Actual payload Base64 length (${payloadB64Len}) does not match expected circuit constant MAX_PAYLOAD_B64_LENGTH (${MAX_PAYLOAD_B64_LENGTH}). Adjust JWT payload content.`);
        }

        // Convert Base64 string to ASCII bytes
        const payloadB64AsciiBytes = new TextEncoder().encode(payloadB64);

        // Create storage of the *exact* required size (no padding)
        const payload_b64_storage = Array.from(payloadB64AsciiBytes);

        console.log(`[prepareJwtInputs] DEBUG: payload_b64_storage created with EXACT length ${payloadB64Len}`);
        // --- Log the array content for debugging --- 
        console.log('[prepareJwtInputs] DEBUG: payload_b64_storage created with MAX length, using UNPADDED payload string');
        // ----------------------------------------------------

        // Format Nationality Claim Storage
        console.log(`[prepareJwtInputs] Formatting expected ${NATIONALITY_CLAIM_KEY} claim storage: ${EXPECTED_NATIONALITY_VALUE}`);
        const expectedNationalityBytes = Array.from(Buffer.from(EXPECTED_NATIONALITY_VALUE, 'utf-8'));
        const expected_nationality_storage = Array(MAX_CLAIM_LENGTH).fill(0);
        expectedNationalityBytes.forEach((byte, index) => {
            if (index < MAX_CLAIM_LENGTH) {
                expected_nationality_storage[index] = byte;
            }
        });
        const expected_nationality_len = Math.min(expectedNationalityBytes.length, MAX_CLAIM_LENGTH);

        // Prepare final TOML data structure matching main.nr inputs
        console.log('[prepareJwtInputs] Constructing final inputs object...');
        const finalTomlData = {
            // --- Private Inputs ---
            signed_data_storage: getArrayFromNoirInput(baseInputs.data as { storage: number[]; len: number }),
            signed_data_len: baseInputs.data ? baseInputs.data.len : 0,
            payload_b64_storage: payload_b64_storage, // Use the exact length array
            decoded_payload_len: decoded_payload_len,
            signature_limbs: baseInputs.signature_limbs,
            redc_params_limbs: baseInputs.redc_params_limbs,
            claim_value_indices: claim_value_indices,
            pubkey_modulus_limbs: baseInputs.pubkey_modulus_limbs, // Private input now
            expected_nationality_storage: expected_nationality_storage,
            expected_nationality_len: expected_nationality_len,
            
            // --- Public Inputs ---
            wallet_address: PLACEHOLDER_WALLET_ADDRESS, 
        };

        // Convert to TOML string
        console.log('[prepareJwtInputs] Formatting TOML string...');
        let tomlString = "";
        for (const key in finalTomlData) {
            if (Object.prototype.hasOwnProperty.call(finalTomlData, key)) {
                const value = (finalTomlData as any)[key];
                 if (value !== undefined) { // Only write defined values
                     tomlString += `${key} = ${formatTomlValue(value)}
`;
                 }
            }
        }

        // Write Prover.toml
        const outputTomlPath = path.resolve(process.cwd(), '..', 'circuit', 'Prover.toml');
        console.log(`[prepareJwtInputs] Writing TOML to: ${outputTomlPath}`);
        fs.writeFileSync(outputTomlPath, tomlString);
        console.log(`[prepareJwtInputs] Prover.toml written successfully.`);

    } catch (error) {
        console.error('\n[prepareJwtInputs] Error during input preparation:', error);
        process.exitCode = 1;
    }
    console.log('[prepareJwtInputs] Script finished');
}

// --- Run ---
prepareInputs(); 